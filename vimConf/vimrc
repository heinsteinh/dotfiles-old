set nocompatible        " Use Vim settings, rather than Vi settings
set langmenu=en
set encoding=utf-8

set nobackup
set nowritebackup
set noswapfile


" Use commas as leaders
let mapleader = ','
let maplocalleader = ','
let g:mapleader = ','

"{{{ OS Variable initialization and Config Dir 
let g:is_win   = has('win32') || has('win64')
let g:is_mac   = has('mac') || system('uname') =~? '^darwin'
let g:is_linux = !g:is_mac && has('unix')
"}}}

"{{{ Simple Branch Template Example
if g:is_win
elseif g:is_mac
elseif g:is_linux
endif

if g:is_win
elseif g:is_linux
endif
"}}}

"{{{ Python DLL and Dir Path
if hostname() == "BHI4PCH7D3"
    let &pythonthreehome='C:\Program Files (x86)\Microsoft Visual Studio\Shared\Python37_64'
    let &pythonthreedll='C:\Program Files (x86)\Microsoft Visual Studio\Shared\Python37_64\python37.dll'

else
endif
"}}}

if g:is_win
    :let $VIMFILE_DIR = 'vimfiles'
else
    :let $VIMFILE_DIR = '.vim'
endif

"echo "Current Hostname :: " 
"echo hostname()
"echo $HOME
"echo $VIMFILE_DIR


if g:is_win

    "set filetype=dos
    "set ffs=dos,unix,mac
    "set path=.,d:/MinGW/include/,d:/MinGW/msys/1.0/include
elseif g:is_linux

    "set filetype=unix
    "set ffs=unix
    set path=.,/usr/include/,/usr/include/c++/4.7/ "c++ is in /usr/include/c++/
    " Allows you to enter sudo pass and save the file
    " " when you forgot to open your file with sudo
    cmap w!! %!sudo tee > /dev/null %
endif



"{{{ Plugin Installation Section
filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'


source $HOME/$VIMFILE_DIR/plugins_vimrc.vim


" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required
" To ignore plugin indent changes, instead use:


" Golden Ratio:
" This should disable the plugin, use :GoldenRatioToggle to reenable.
let g:loaded_golden_ratio=1

" show errors in different Colors
highlight Errors ctermbg=green guibg=darkred

"}}}


"{{{ Settings Section
source $HOME/$VIMFILE_DIR/settings_vimrc.vim  


"{{{ Source architecture config dependency 
if g:is_win
    if filereadable(expand('$HOME/$VIMFILE_DIR/vimrc.win'))
        "echo "sourcing win dir
        source $HOME/$VIMFILE_DIR/vimrc.win
    endif
elseif g:is_mac
    if filereadable(expand("$HOME/$VIMFILE_DIR/vimrc.mac"))
        source  $HOME/$VIMFILE_DIR/vimrc.mac
    endif
elseif g:is_linux
    if filereadable(expand("$HOME/$VIMFILE_DIR/vimrc.linux"))
        source  $HOME/$VIMFILE_DIR/vimrc.linux
    endif
endif
"}}}
"}}}

"Vimrc quick edit
nnoremap <Leader>pv :split $MYVIMRC<CR>
nnoremap <Leader>vv :vsplit $MYVIMRC<CR>
nnoremap <Leader>rv :source $MYVIMRC<CR>:echo "Reloaded: " . $MYVIMRC<CR>
nnoremap <Leader>r  :source $MYVIMRC<CR>:echo "Reloaded: " . $MYVIMRC<CR>
nnoremap <Leader>tv :tabnew $MYVIMRC<CR>
nnoremap <Leader>ev :edit $MYVIMRC<CR>

" Quick PluginStall
nnoremap <Leader>pi :source $MYVIMRC<cr>:PluginInstall<cr>




"{{{ Gui Running config
if has("gui_running")

    echo "sourcing from Gui"
    set encoding=utf-8
    " Always show cursor
    set ruler
    " Highlight the current line
    set cursorline


    set guioptions+=a           " Autoselect text
    set guioptions+=c           " Use console dialogs

    " Hide the toolbar
    set guioptions-=T
    "set guioptions-=m  "remove menu bar
    set guioptions-=T  "remove toolbar
    set guioptions-=r  "remove right-hand,scroll bar
    set guioptions-=L  "remove left-hand scroll bar

    if hostname() == "BHI4PCH7D3"
        set lines=70 columns=230
    else
        "autocmd GUIEnter * simalt ~x
    endif
    if g:is_win
        " set guifont=FiraCode_Nerd_Font_Mono:h10
        " set guifont=FiraCode\ Nerd\ Font\ Mono:h10
        " set guifont=FiraCode\ Nerd\ Font\ Mono:h12:style=Retina
        set guifont=FiraCode\ Nerd\ Font\ Mono:h13
        if has('gui_win32')
            "set guifont=FiraCode_Nerd_Font_Mono:h13:cANSI
            set guifont=FiraCode_Nerd_Font_Mono:h10:W500:cANSI:qDRAFT
            "            set guifont=FiraCode_Nerd_Font_Mono:h11:W500:cANSI:qDRAFT
            "set guifont=Hack_Nerd_Font_Mono:h10:cANSI:qDRAFT  
        else
            "set guifont=DejaVu\ Sans\ Mono\ 13
            set guifont=Fira\ Code\ Medium\ 10
        endif

        "au GUIEnter * simalt ~x

    elseif g:is_linux
        "set guifont=Ubuntu\ Mono\ Regular\ 13
        set guifont=Fira\ Code\ Medium\ 10
    endif

    nnoremap <A-n>  :confirm enew<CR>
    inoremap <A-n>  :confirm enew<CR>

    " Open the GUI file browser.
    " CTRL-O is Quickopen file
    noremap <A-o> :browse confirm e<CR>
    vnoremap <A-o> :browse confirm e<CR>
    inoremap <A-o> :browse confirm e<CR>

    " CTRL-W is Quicksave as.. file
    noremap <A-w> :browse confirm saveas<CR>
    vnoremap <A-w> :browse confirm saveas<CR>
    inoremap <A-w> :browse confirm saveas<CR>
    "Useful to find out how the font is set in guifont :set guifont?
    map <F3> <Esc>:set guifont=*<CR> 
else
    echo "sourcing from Terminal "
    set t_Co=256
    set nocursorline  

    if g:is_win
    elseif g:is_linux
        set term=xterm-256color
    endif
endif
"}}}

"{{{ source all the helper files
for f in split(glob('$HOME/$VIMFILE_DIR/functions/*.vim'), '\n')
    "echo "sourcing dir "
    "echo f
    exec 'source' f
endfor

"}}}

"{{{ Special setting for ConEmu
"http://conemu.github.io/en/VimXterm.html
if g:is_win && !has("gui_running")
    " 256-color
    set term=xterm
    set t_Co=256
    let &t_AB="\e[48;5;%dm"
    let &t_AF="\e[38;5;%dm"
    colorscheme desert
    "colorscheme zenburn

    " Enable mouse interaction
    set mouse=a
endif
"}}}




" Useful mappings
"{{{ Mappings Movement 
nnoremap <leader>et :exec ":vsp $HOME/notes/" . strftime('%m-%d-%y') . ".md"<CR>

" Double tap s to save the buffer contents,more convienent than keep the pressure on the modifier keys to be CUA compatible.
nnoremap <silent> ss :update<CR>

"Map \e to edit a file from the directory of the current buffer
nnoremap <Leader>e :e <C-R>=expand("%:p:h") . "/"<CR>

"}}}



"{{{ Copy/Paste
""https://github.com/jwbat/dotfiles/blob/4fc36a3eda20ed4467b21dd863507fa2c31b80d5/.vimrc#L131
"Good Register paste example in this link
"
" yank to system clipboard
xnoremap <leader>c "+y
nnoremap <leader>c "+y
" paste from system clipboard and go end of the paste
nnoremap <leader>v "+p`]
" cut line(s) into system clipboard
xnoremap <leader>x"+d

nnoremap <C-Insert> "*y
nnoremap <S-Insert> "*p
vnoremap <C-Insert> "*y
vnoremap <S-Insert> "*p

" Copy entire file to clipboard
nnoremap Y :%y+<cr>


""copy visual text into register u
""replace visual text with text from u
vnoremap <leader><leader>yu "uy
vnoremap <leader><leader>pu "uP
noremap <leader><leader>yu "uy
noremap <leader><leader>pu "uP

noremap <leader><leader>pa "aP
noremap <leader><leader>ya "ay

nnoremap <leader><leader>yv "vy
nnoremap <leader><leader>pv "vP
vnoremap <leader><leader>yv "uy
vnoremap <leader><leader>pv "uP
"}}}

" remap movement keys so that up-down work over visual lines rather than 
" actual lines
noremap j gj
noremap k gk

"remap jk/kj to escape
inoremap jk <Esc>
inoremap kj <Esc>


" quick scroll down/up
nnoremap J Lzz
vnoremap J Lzz
nnoremap K Hzz
vnoremap K Hzz


" Map 0 to first non-blank character
nnoremap 0 ^

" Move to the end of the line
nnoremap L $zL
vnoremap L $
nnoremap H 0zH
vnoremap H 0

""indent/unindent visual mode selection with tab/shift+tab
"vmap <tab> >gv
"vmap <s-tab> <gv

" Copy number of lines and paste below
nnoremap <leader>cp :<c-u>exe 'normal! y' . (v:count == 0 ? 1 : v:count) . 'j' . (v:count == 0 ? 1 : v:count) . 'jo<C-v><Esc>p'<cr>



" Windows mappings
nnoremap <c-w>v :vnew<cr>
nnoremap <c-w>s :new<cr>
nnoremap <c-w>e :enew<cr>

" Delete current buffer
nnoremap <silent> <leader>bd :bp <bar> bd #<cr>
" Close current buffer
nnoremap <silent> <leader>bc :close<cr>

" This creates a new line of '=' signs the same length of the line
nnoremap <leader>o yypVr=



" Map dp and dg with leader for diffput and diffget
nmap <leader>dp :diffput<cr>
nmap <leader>dg :diffget<cr>
nmap <leader>du :windo diffoff <bar> windo diffupdate<cr>
nmap <leader>dn :windo diffthis<cr>
nmap <leader>df :windo diffoff<cr>



" Backspace in normal mode
nnoremap <bs> d1<Left>
" CTRL-D to delete line
inoremap <C-D> <Esc>dd<Insert>
nnoremap <C-D> dd
" CTRL-Z to undo
inoremap <C-Z> <Esc>u<Insert>
nnoremap <C-Z> u
" CTRL-Y to redo
inoremap <C-Y> <Esc><C-R><Insert>
nnoremap <C-Y> <C-R>
" CTRL-S to save
inoremap <C-S> <Esc>:w<Enter><Insert>
nnoremap <C-S> :w<Enter>

" [COMMAND+INSERT+VISUAL] CTRL-S Save file
nnoremap <C-s> :w!<CR>
inoremap <C-s> <esc>:w!<CR>gi
vnoremap <C-s> <esc>:w!<CR>gv=gv

" [COMMAND] TAB go to next tab
"nnoremap <TAB> gt

" [COMMAND] SHIFT-TAB go to previous tab
nnoremap <S-TAB> gT

" [INSERT+VISUAL] SHIFT-TAB remove indent/tab
inoremap <S-TAB> <C-d>
vnoremap <S-TAB> <gv

" [COMMAND] CTRL-N new tab
nnoremap <C-n> :tabnew<CR>


""Should find another mapper for this w. mgt
nnoremap <c-Down>  <c-w>-
nnoremap <c-Right> <c-w><
nnoremap <c-Up>    <c-w>+
nnoremap <c-Left>  <c-w>>

"Split window resize
nnoremap <leader>j :resize +5<CR>
nnoremap <leader>k :resize -5<CR>
nnoremap <leader>h :vertical resize +5<CR>
nnoremap <leader>l :vertical resize -5<CR>


" Move Line Up and Dow in all Tree main Mode 
nnoremap <C-j> :m .+1<CR>==
nnoremap <C-k> :m .-2<CR>==
inoremap <C-j> <Esc>:m .+1<CR>==gi
inoremap <C-k> <Esc>:m .-2<CR>==gi
vnoremap <C-j> :m '>+1<CR>gv=gv
vnoremap <C-k> :m '<-2<CR>gv=gv


" Map - to move a line down and _ a line up
nnoremap - "ldd$"lp
nnoremap _ "ldd2k"lp


" [EDIT+VISUAL+COMMAND] CTRL-K UP Split above
nnoremap <C-S-Up> :above split<CR>
inoremap <C-S-Up> <ESC>:above split<CR>gi
vnoremap <C-S-Up> <ESC>:above split<CR>gv=gv

" [EDIT+VISUAL+COMMAND] CTRL-K DOWN Split below
nnoremap <C-S-Down> :below split<CR>
inoremap <C-S-Down> <ESC>:below split<CR>gi
vnoremap <C-S-Down> <ESC>:below split<CR>gv=gv

" [EDIT+VISUAL+COMMAND] CTRL-K LEFT Split left
nnoremap <C-S-Left> :vsplit<CR>
inoremap <C-S-Left> <ESC>:vsplit<CR>gi
vnoremap <C-S-Left> <ESC>:vsplit<CR>gv=gv

" [EDIT+VISUAkL+COMMAND] CTRL-K RIGHT Split right
nnoremap <C-S-Right> :botright vsplit<CR>
inoremap <C-S-Right> <ESC>:botright vsplit<CR>gi
vnoremap <C-S-Right> <ESC>:botright vsplit<CR>gv=gv



" [EDIT+VISUAL+COMMAND] ALT-LEFT switch to left or next window
nnoremap <M-Right> :wincmd l<CR>
inoremap <M-Right> <ESC>:wincmd l<CR>gi
vnoremap <M-Right> <ESC>:wincmd l<CR>gv=gv

" [EDIT+VISUAL+COMMAND] ALT-RIGHT switch to right previous window
nnoremap <M-Left> :wincmd h<CR>
inoremap <M-Left> <ESC>:wincmd h<CR>gi
vnoremap <M-Left> <ESC>:wincmd h<CR>gv=gv

" [EDIT+VISUAL+COMMAND] ALT-UP switch to window above current
nnoremap <M-Up> :wincmd k<CR>
inoremap <M-Up> <ESC>:wincmd k<CR>gi
vnoremap <M-Up> <ESC>:wincmd k<CR>gv=gv

" [EDIT+VISUAL+COMMAND] ALT-DOWN switch to window below current
nnoremap <M-Down> :wincmd j<CR>
inoremap <M-Down> <ESC>:wincmd j<CR>gi
vnoremap <M-Down> <ESC>:wincmd j<CR>gv=g
"}}}


"Experiment 
"https://github.com/jabrouwer82/configurations/blob/ab816a9b08b394b7cd114a912d4e04c926b46345/.vimrc

" Switch windows
noremap <leader><Up> :wincmd k<CR>
noremap <leader><Down> :wincmd j<CR>
noremap <leader><Left> :wincmd h<CR>
noremap <leader><Right> :wincmd l<CR>

" Move windows.
noremap <leader>J :wincmd J<CR>
noremap <leader>K :wincmd K<CR>
noremap <leader>H :wincmd H<CR>
noremap <leader>L :wincmd L<CR>


"" Esc to enter terminal normal mode
"tnoremap <Esc> <C-\><C-n>

" Ctrl-Shift-V to paste.
" Terminal Mode
tnoremap <C-A-V> <C-W>"+
" Normal Mode.
nnoremap <C-A-V> p
" Insert Mode.
inoremap <C-A-V> <C-R><C-O>+
" Command Line Mode.
cnoremap <C-A-V> <C-R>+

" Center the cursor when jumping between search matches.
noremap n nzz
noremap N Nzzo

" Search mappings
nnoremap <silent> * :execute "normal! *N"<cr>
nnoremap <silent> # :execute "normal! #n"<cr>


" Search visually selected text with // or * or #
vnoremap // y/\V<C-R>=escape(@",'/\')<CR><CR>


" <leader>s will prepare a :s command for the current word/selection.
"vnoremap <leader>s y:%s/<C-r>"\C/<C-r>"/g
"nnoremap <leader>s :%s/<C-r><C-w>\C/<C-r><C-w>/g

" Search and Replace
nnoremap <Leader>s :.,$s?<C-r><C-w>?<C-r><C-w>?gc<Left><Left><Left>
vnoremap <leader>s "hy:.,$s?<C-r>h?<C-r>h?gc<left><left><left>

vnoremap <leader>dab "hyqeq:v?\V<c-r>h?d E<cr>:let @"=@e<cr>:noh<cr>
vnoremap <leader>daa "hyqeq:g?\V<c-r>h?d E<cr>:let @"=@e<cr>:noh<cr>

vnoremap <leader>yab "hymmqeq:v?\V<c-r>h?yank E<cr>:let @"=@e<cr>`m:noh<cr>
vnoremap <leader>yaa "hymmqeq:g?\V<c-r>h?yank E<cr>:let @"=@e<cr>`m:noh<cr>



" Pressing enter will clear search highlighting.
"nnoremap <CR> :noh<CR>
nnoremap <silent> <CR> :noh<CR>


" <leader>t to create new tab.
noremap <leader>t :tabnew<CR>
" <leader>tt to create new terminal tab.
noremap <leader>tt :tabnew<CR>:term ++curwin<CR>
" <leader>tc to close the current tab.
noremap <leader>tc :tabc<CR>


"Switch buffers
nnoremap ü :bnext<CR>
nnoremap ö :bprevious<CR>

"{{{ Comment text
nmap <leader>cc :Commentary<CR>
vmap <leader>cc :Commentary<CR>
"}}}"

" Turn On/Off NERDTree
map <leader>n :NERDTreeToggle %<CR>

" Reindent file and return to current line
map <leader>i mmgg=G`m<cr>


" Strip all trailing whitespace from a file, using ,W
nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>


" Folding rules {{{
function! MyFoldText()
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4
    return line . ' …' . repeat(" ",fillcharcount) . foldedlinecount . ' '
endfunction
set foldtext=MyFoldText()

" Mappings to easily toggle fold levels
nnoremap z0 :set foldlevel=0<cr>
nnoremap z1 :set foldlevel=1<cr>
nnoremap z2 :set foldlevel=2<cr>
nnoremap z3 :set foldlevel=3<cr>
nnoremap z4 :set foldlevel=4<cr>
nnoremap z5 :set foldlevel=5<cr>

nnoremap <space> za
vnoremap <Space> za
nnoremap zo zr
nnoremap zO zR
nnoremap zc zm
nnoremap zC zM


" create fold (visual select)
vnoremap <space> zf

" close other folds
nnoremap zo zMzv


hi Folded guibg=bg
hi Folded guifg='orange'
"}}}

" Netrw (directory browsing) out-of-the-box plugin {{{
let g:netrw_banner = 0
let g:netrw_liststyle = 3
let g:netrw_browse_split = 4
let g:netrw_altv = 1
let g:netrw_winsize = 25
let g:netrw_keepdir = 1
" augroup ProjectDrawer
"   autocmd!
"   autocmd VimEnter * :if !exists("NERDTree") | Vexplore | endif
" augroup END

"map <silent> <C-o> :Lexplore<CR>
" }}}


" " Use ag for search
" if executable('rg')
"   set grepprg=rg\ --vimgrep\ --no-heading\ --smart-case
" elseif executable('ag')
"   set grepprg=ag\ --vimgrep\ --follow
" endif

"" Populate current word in search
"nnoremap <leader>/ :grep '\b<C-R>=substitute(expand("<cword>"), '#', '\\#', 'g')<CR>\b'<space>

" " Grep {{{
" " This is only availale in the quickfix window, owing to the filetype
" " restriction on the autocmd (see below).
" function! <SID>OpenQuickfix(new_split_cmd)
"   " 1. the current line is the result idx as we are in the quickfix
"   let l:qf_idx = line('.')
"   " 2. jump to the previous window
"   wincmd p
"   " 3. switch to a new split (the new_split_cmd will be 'vnew' or 'split')
"   execute a:new_split_cmd
"   " 4. open the 'current' item of the quickfix list in the newly created buffer
"   "    (the current means, the one focused before switching to the new buffer)
"   execute l:qf_idx . 'cc'
" endfunction

" augroup grep_augroup
"   autocmd!
"   autocmd QuickFixCmdPost [^l]* copen
"   autocmd QuickFixCmdPost l*    lopen
"   autocmd FileType qf nnoremap <buffer> <C-v> :call <SID>OpenQuickfix("vnew")<CR>
"   autocmd FileType qf nnoremap <buffer> <C-x> :call <SID>OpenQuickfix("split")<CR>
" augroup END

" " Set grepprg as RipGrep or ag (the_silver_searcher), fallback to grep
" if executable('rg')
"   let &grepprg="rg --vimgrep --no-heading --smart-case --hidden --follow -g '!{" . &wildignore . "}' $*"
"   set grepformat=%f:%l:%c:%m,%f:%l:%m
" elseif executable('ag')
"   let &grepprg='ag --vimgrep --smart-case --hidden --follow --ignore "!{' . &wildignore . '}" $*'
"   set grepformat=%f:%l:%c:%m
" else
"   let &grepprg='grep -n -r --exclude=' . shellescape(&wildignore) . ' . -- $*'
" endif

" function s:RipGrepCWORD(bang, visualmode, ...) abort
"   let search_word = a:1

"   if a:visualmode
"     " Get the line and column of the visual selection marks
"     let [lnum1, col1] = getpos("'<")[1:2]
"     let [lnum2, col2] = getpos("'>")[1:2]

"     " Get all the lines represented by this range
"     let lines = getline(lnum1, lnum2)

"     " The last line might need to be cut if the visual selection didn't end on the last column
"     let lines[-1] = lines[-1][: col2 - (&selection ==? 'inclusive' ? 1 : 2)]
"     " The first line might need to be trimmed if the visual selection didn't start on the first column
"     let lines[0] = lines[0][col1 - 1:]

"     " Get the desired text
"     let search_word = join(lines, "\n")
"   endif
"   if search_word ==? ''
"     let search_word = expand('<cword>')
"   endif
"   echom 'Searching for ' . search_word
"   " Silent removes the "press enter to continue" prompt, and band (!) is for
"   " not jumping to the first result
"   let grepcmd = 'silent grep' . a:bang .' -- ' . shellescape(search_word)
"   execute grepcmd
" endfunction
" command! -bang -range -nargs=? RipGrepCWORD call <SID>RipGrepCWORD("<bang>", v:false, <q-args>)
" command! -bang -range -nargs=? RipGrepCWORDVisual call <SID>RipGrepCWORD("<bang>", v:true, <q-args>)
" nmap <c-e> :RipGrepCWORD!<Space>
" vmap <c-e> :RipGrepCWORDVisual!<cr>
" " }}}


" Terminal configurations {{{
if exists(':terminal')

    if !exists('g:terminal_ansi_colors')
        let g:terminal_ansi_colors = [
                    \'#21222C',
                    \'#FF5555',
                    \'#69FF94',
                    \'#FFFFA5',
                    \'#D6ACFF',
                    \'#FF92DF',
                    \'#A4FFFF',
                    \'#FFFFFF',
                    \'#636363',
                    \'#F1FA8C',
                    \'#BD93F9',
                    \'#FF79C6',
                    \'#8BE9FD',
                    \'#F8F8F2',
                    \'#6272A4',
                    \'#FF6E6E'
                    \]
    endif

    " Function to set terminal colors
    fun! s:setTerminalColors()
        if exists('g:terminal_ansi_colors')
            for i in range(len(g:terminal_ansi_colors))
                exe 'let g:terminal_color_' . i . ' = g:terminal_ansi_colors[' . i . ']'
            endfor
            unlet! g:terminal_ansi_colors
        endif
    endfunction

    augroup TerminalAugroup
        autocmd!

        " Start terminal in insert mode
        autocmd BufEnter * if &buftype == 'terminal' | :startinsert | endif

        " Call terminal colors function only after colorscheme changed
        autocmd Colorscheme * call <sid>setTerminalColors()
    augroup END

    tnoremap <Esc> <C-\><C-n>

    " To force using 256 colors
    set t_Co=256
endif

" }}}

source $HOME/$VIMFILE_DIR/plugins/settings_nerdtree.vim
source $HOME/$VIMFILE_DIR/plugins/settings_rooter.vim
source $HOME/$VIMFILE_DIR/plugins/settings_tagbar.vim
source $HOME/$VIMFILE_DIR/plugins/settings_tagbar.vim
source $HOME/$VIMFILE_DIR/plugins/settings_ultisnips.vim
source $HOME/$VIMFILE_DIR/plugins/settings_airline.vim
source $HOME/$VIMFILE_DIR/plugins/settings_ycm.vim
source $HOME/$VIMFILE_DIR/plugins/settings_rainbow.vim


source $HOME/$VIMFILE_DIR/settings/settings_vim_cpp.vim
source $HOME/$VIMFILE_DIR/settings/settings_cpp.vim
source $HOME/$VIMFILE_DIR/settings/fzf-spell.vim

source $HOME/$VIMFILE_DIR/plugins/backupFiles.vim
source $HOME/$VIMFILE_DIR/plugins/color-devicons.vim
source $HOME/$VIMFILE_DIR/plugins/backupFiles.vim
source $HOME/$VIMFILE_DIR/plugins/automkdir.vim
source $HOME/$VIMFILE_DIR/plugins/diminactive.vim
source $HOME/$VIMFILE_DIR/plugins/settings_fzf.vim
source $HOME/$VIMFILE_DIR/plugins/settings_programming.vim

"{{{  LargeFile
function! LargeFile()
    " No need for the extra IO of making the swap/backup/undo files.
    setlocal noswapfile nobackup nowritebackup noundofile
    " Disable syntax highlighting and similar ft plugins.
    setlocal eventignore+=FileType
    " Display message once buffer is open.
    autocmd ++once BufEnter *  echom "The file is larger than " . g:large_fsize . " MB, so some options are changed."
endfunction
"}}}

"{{{ AutoCommand
if has ('autocmd') " Remain compatible with earlier versaons
    " automatically rebalance windows on vim resize
    autocmd VimResized * :wincmd =

    "enable rainbow it globally
    au FileType c,cpp,objc,objcpp call rainbow#load()
    "let g:rainbow_active = 1

    autocmd FileType sh set foldmethod=indent
    autocmd FileType c,cpp set foldmethod=syntax 
    " " Enable marker folds for .vimrc files and shell files
    autocmd FileType vim,sh setlocal foldmethod=marker
    "autocmd BufRead * normal zM

    autocmd filetype gitcommit setlocal spell spelllang=en_us

    " Easier closing of vim help menus.
    augroup helpft
        au!
        au FileType help noremap <buffer> q :q<CR>
    augroup end

    " Easier closing of bufferized commands.
    augroup bufferizeft
        au!
        au FileType bufferize noremap <buffer> q :q<CR>
    augroup end

    " autowrite[all] only saves in certain situations, leaving a window is another situation that I think should autosave.
    augroup AutoWre
        au!
        au WinLeave * silent! update
    augroup end

    " Center the cursor when switching to a buffer.
    augroup BufCursorCenter
        au!
        au BufWinEnter * normal zz
    augroup end

    " Save the reltime that vim starts.
    augroup StartTime
        au!
        au VimEnter * let g:start_time=reltime()
    augroup end

    " Disables the swap file for unmodified buffers.
    augroup SwpControl
        au!
        autocmd BufWritePost,BufReadPost,BufLeave *
                    \ if isdirectory(expand("<amatch>:h")) | let &l:swapfile = &modified | endif
    augroup end

    " Automatically write any updates in the current file when focus is lost.
    augroup focuslost
        au!
        au FocusLost * silent! update
    augroup end

    let g:large_fsize = 10
    augroup LargeFile 
        au!
        autocmd BufReadPre *
                    \ let f=getfsize(expand("<afile>")) / 1024 / 1024 | if f > g:large_fsize || f == -2 | call LargeFile() | endif
    augroup end

    " Make terminal-mode not wrap lines, because it does it wrong: https://github.com/vim/vim/issues/2865
    " Also disable spell checking because it highlights stupid stuff like powerline glyphs.
    " Disabled - Suspend job output when leaving the buffer or window, so that the window fades correctly.
    augroup termft
        au!
        au BufEnter,BufWinEnter *
                    \ if &buftype=='terminal'
                    \ |   setlocal nowrap
                    \ |   setlocal nospell
                    \ | endif
        " au FocusLost,WinLeave *
        "   \ if &buftype=='terminal' && mode() == 't'
        "   \ |   call feedkeys("\<C-\>\<C-N>", 'x')
        "   " \ |   call term_setsize('', term_getsize('')[0], term_getsize('')[1]+6)
        "   \ | endif
    augroup end

    " Allow escape in fzf windows.
    augroup fzfft
        au!
        au FileType fzf tmap <buffer> <Esc> <Esc>
    augroup end

    " When editing a file, always jump to the last known cursor position.
    " Don't do it when the position is invalid, when inside an event handler (happens when dropping a file on gvim) and
    " for a commit message (it's likely a different one than last time).
    augroup autocursorpos
        au!
        autocmd BufReadPost *
                    \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
                    \ |   exe "normal! g`\""
                    \ | endif
    augroup end


    "autocmd BufEnter * silent! lcd %:p:h
    "autocmd BufEnter .vimrc,*.vim,*.cpp,*.c,*.java,*.py :TagbarOpen
    "autocmd BufEnter *.cpp,*.c,*.java,*.py :TagbarOpen



    " Automatic rename of tmux window
    " if exists('$TMUX') && !exists('$NORENAME')
    if exists('$TMUX')
        " if &term =~ "screen"
        augroup vimrc-screen
            autocmd!
            autocmd BufEnter * call system("tmux rename-window " . "'[" . expand("%:t") . "]'")
            autocmd VimLeave * call system("tmux set-window automatic-rename on")
            autocmd BufEnter * let &titlestring = ' ' . expand("%:t")
        augroup END
    end

endif " has autocmd


source $HOME/$VIMFILE_DIR/settings/AutoCommand.vim

"}}}

